/** * Fire by Grant Skinner. * Modified by: Giraldo Rosales * Visit www.liquidgear.net for documentation and updates. * * * Copyright (c) 2010 Nitrogen Labs, Inc. All rights reserved. *  * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the "Software"), to deal in the Software without * restriction, including without limitation the rights to use, * copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following * conditions: *  * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE.**/package lg.flash.effects {	//Flash Classes	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Point;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.filters.BlurFilter;	import flash.filters.ColorMatrixFilter;	import flash.filters.DisplacementMapFilter;	import flash.events.Event;	//LG Classes	import lg.flash.elements.VisualElement;		public class Fire extends Sprite {		/** @private **/		private var _fadeRate:Number=0.4;		/** @private **/		private var _distortionScale:Number=0.4;		/** @private **/		private var _distortion:Number=0.5;		/** @private **/		private var _flameHeight:Number=0.3;		/** @private **/		private var _flameSpread:Number=0.3;		/** @private **/		private var _blueFlame:Boolean = false;		/** @private **/		private var _smoke:Number = 0;		/** @private **/		private var displayBmp:BitmapData;		/** @private **/		private var scratchBmp:BitmapData;		/** @private **/		private var perlinBmp:BitmapData;		/** @private **/		private var mtx:Matrix;		/** @private **/		private var pnt:Point;		/** @private **/		private var drawColorTransform:ColorTransform;		/** @private **/		private var fireCMF:ColorMatrixFilter;		/** @private **/		private var dispMapF:DisplacementMapFilter;		/** @private **/		private var blurF:BlurFilter;		/** @private **/		private var endCount:Number;		/** @private **/		private var bmpsValid:Boolean=false;		/** @private **/		private var perlinValid:Boolean=false;		/** @private **/		private var filtersValid:Boolean=false;		/** @private **/		private var _target:VisualElement;				/** Create a fire effect on an element. Set it in flames and enjoy! **/		public function Fire(element:VisualElement) {			this.name	= 'fire_'+element.name;			//this.x	= -(element.width*1.5);//			this.y	= -100;			//			element.addChild(this);//			element.setChildIndex(this, 0);						_target	= element;			clear();						graphics.beginFill(0x000000, 0);			graphics.drawRect(0, 0, element.width*5, element.height*5);			graphics.endFill();			this.x	= element.x - element.width*1.25;			this.y	= element.y - element.height*1.25;						addEventListener(Event.ADDED_TO_STAGE, onStage);						mtx = new Matrix();			pnt = new Point();						startFire();		}				/** @private **/		private function onStage(e:Event):void {			//graphics.clear();			//graphics.beginFill(0x000000, 0);			//graphics.drawRect(0, 0, this.stage.stageWidth, this.stage.stageHeight);			//graphics.endFill();		}				override public function set width(value:Number):void {			bmpsValid &&= (value == width);			super.width = value|0;		}		override public function get width():Number {			return super.width;		}				override public function set height(value:Number):void {			bmpsValid &&= (value == height);			super.height = value|0;		}		override public function get height():Number {			return super.height;		}				[Inspectable(defaultValue=0.4,name='fadeRate (0-1)')]		/**         * Sets the rate that flames fade as they move up. 0 is slowest, 1 is fastest.         * @default 0.4		 */		public function set fadeRate(value:Number):void {			filtersValid &&= (value == _fadeRate);			_fadeRate = value;		}		public function get fadeRate():Number {			return _fadeRate;		}				[Inspectable(defaultValue=0.4,name='distortionScale (0-1)')]		/**         * Sets the scale of flame distortion. 0.1 is tiny and chaotic, 1 is large and smooth.         * @default 0.4		 */		public function set distortionScale(value:Number):void {			perlinValid &&= (value == _distortionScale);			_distortionScale = value;		}		public function get distortionScale():Number {			return _distortionScale;		}				[Inspectable(defaultValue=0.4,name='distortion (0-1)')]		/**         * Sets the amount of distortion. 0.1 is little, 1 is chaotic.         * @default 0.4		 */		public function set distortion(value:Number):void {			filtersValid &&= (value == _fadeRate);			_distortion = value;		}		public function get distortion():Number {			return _distortion;		}				[Inspectable(defaultValue=0.3,name='flameHeight (0-1)')]		/**         *	Sets the how high the flame will burn. 0 is zero gravity, 1 is a bonfire.         *	@default 0.3		 */		public function set flameHeight(value:Number):void {			perlinValid &&= (value == _flameHeight);			_flameHeight = value;		}		public function get flameHeight():Number {			return _flameHeight;		}				[Inspectable(defaultValue=0.3,name='flameSpread (0-1)')]		/**		*	Sets the how much the fire will spread out around the target. 0 is no spread, 1 is a lot. 		*	@default .3		**/        public function set flameSpread(value:Number):void {			filtersValid &&= (value == _flameSpread);			_flameSpread = value;		}		public function get flameSpread():Number {			return _flameSpread;		}				[Inspectable(defaultValue=false,name='blueFlame')]		/**		*	Indicates whether it should use a blue or red flame. 		*	@default false		**/        public function set blueFlame(value:Boolean):void {			filtersValid &&= (value == _blueFlame);			_blueFlame = value;		}		public function get blueFlame():Boolean {			return _blueFlame;		}				[Inspectable(defaultValue=0,name='smoke (0-1)')]		/**		*	Sets the amount of smoke. 0 little, 1 lots.		*	@default false		**/		public function set smoke(value:Number):void {			filtersValid &&= (value == _smoke);			_smoke = value;		}		public function get smoke():Number {			return _smoke;		}				/** Clears the fire. **/		public function clear():void {			if (displayBmp) {				displayBmp.fillRect(displayBmp.rect,0);			}		}				/** Stops the fire effect after letting it burn down over 20 frames. **/		public function stopFire():void {			if (endCount == 0) { endCount = 20; }		}				/** @private **/		private function updateBitmaps():void {			if(displayBmp) {				displayBmp.dispose();				displayBmp	= null;				scratchBmp.dispose();				scratchBmp	= null;				perlinBmp.dispose();				perlinBmp	= null;			}						displayBmp	= new BitmapData(width, height, true, 0);			scratchBmp	= displayBmp.clone();			perlinBmp	= new BitmapData(width*3, height*3, false, 0);						while (numChildren) { removeChildAt(0); }			addChild(new Bitmap(displayBmp));						updatePerlin();			updateFilters();			bmpsValid = true;		}				/** @private **/		private function updatePerlin():void {			perlinBmp.perlinNoise(30*_distortionScale,20*_distortionScale,1,-Math.random()*1000|0,false,true,1|2,false);			perlinBmp.colorTransform(perlinBmp.rect,new ColorTransform(1,  1-_flameHeight*0.5  ,1,1,0,0,0,0));			perlinValid = true;		}				/** @private **/		private function updateFilters():void {			if (_blueFlame) {				fireCMF = new ColorMatrixFilter([0.8-0.55*_fadeRate,0,0,0,0,												 0,0.93-0.48*_fadeRate,0,0,0,												 0,0.1,0.96-0.35*_fadeRate,0,0,												 0,0.1,0,1,-25+_smoke*24]);				drawColorTransform = new ColorTransform(0,0,0,1,210,240,255,0);			} else {				fireCMF = new ColorMatrixFilter([0.96-0.35*_fadeRate,0.1,0,0,-1,												 0,0.9-0.45*_fadeRate,0,0,0,												 0,0,0.8-0.55*_fadeRate,0,0,												 0,0.1,0,1,-25+_smoke*24]);				drawColorTransform = new ColorTransform(0,0,0,1,255,255,210,0);			}			dispMapF = new DisplacementMapFilter(perlinBmp,pnt,1,2,14*_distortion,-30,"clamp");			blurF = new BlurFilter(32*_flameSpread,32*_flameSpread,1);						filtersValid = true;		}				/** @private **/		private function startFire():void {			endCount = 0;			addEventListener(Event.ENTER_FRAME, doFire);		}				/** @private **/		private function doFire(evt:Event):void {			if (_target == null) { return; }			if (!bmpsValid) { updateBitmaps(); }			if (!perlinValid) { updatePerlin(); }			if (!filtersValid) { updateFilters(); }			if (endCount == 0) {				var drawMtx:Matrix = _target.transform.matrix;				drawMtx.tx = _target.x-x;				drawMtx.ty = _target.y-y;				scratchBmp.fillRect(scratchBmp.rect,0);				drawColorTransform.alphaOffset = -Math.random()*200|0;				scratchBmp.draw(_target,drawMtx,drawColorTransform,"add");				scratchBmp.applyFilter(scratchBmp,scratchBmp.rect,pnt,blurF);				displayBmp.draw(scratchBmp,mtx,null,"add");			}			dispMapF.mapPoint = new Point( -Math.random()*(perlinBmp.width-displayBmp.width)|0, -Math.random()*(perlinBmp.height-displayBmp.height)|0 );			displayBmp.applyFilter(displayBmp,displayBmp.rect,pnt,dispMapF);			displayBmp.applyFilter(displayBmp,displayBmp.rect,pnt,fireCMF);						if (endCount != 0 && --endCount == 0)				removeEventListener(Event.ENTER_FRAME,doFire);		}	}}