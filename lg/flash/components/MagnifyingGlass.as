/*** ElementEvent Class by Filippo Lughi* Modified By Giraldo Rosales.* Visit www.liquidgear.net for documentation and updates.*** Copyright (c) 2010 Nitrogen Labs, Inc. All rights reserved.* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package lg.flash.components {	import flash.display.Sprite;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.filters.DisplacementMapFilter;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.ui.Mouse;		//LG	import lg.flash.elements.VisualElement;	import lg.flash.elements.Shape;	import lg.flash.events.ElementEvent;		public class MagnifyingGlass extends VisualElement {		private var _glass:Shape;		private var _mask:Shape;		private var _container:Sprite	= new Sprite();				private var _bit1:BitmapData;		private var _bit2:BitmapData;		private var _bit3:BitmapData;				private var _filter:DisplacementMapFilter;		private var _isLoaded:Boolean;						public function MagnifyingGlass(obj:Object) {			ghost();						data.width	= (obj.width) ? obj.width : 100;			data.height	= (obj.height) ? obj.height : 100;			data.shape	= (obj.shape) ? obj.shape : 'circle';			data.background	= (obj.background) ? uint(obj.background) : 0xffffff;			data.target	= obj.target;						//Create overlay			graphics.clear();			graphics.beginFill(0x000000, 0);			graphics.drawRect(0, 0, data.target.width, data.target.height);			graphics.endFill();						x	= data.target.x;			y	= data.target.y;						_glass	= new Shape({id:'glass', shape:data.shape, width:data.width, height:data.height, hidden:true});			_mask	= new Shape({id:'maskMag', shape:data.shape, width:data.width, height:data.height, hidden:true});						addChild(_glass);			addChild(_mask);			addChild(_container);						if(data.target.image) {				initGlass();			} else {				data.target.loaded(onLoadTarget);			}		}				private function onLoadTarget(e:ElementEvent):void {			unbind(ElementEvent.ADD, onLoadTarget);			initGlass();		}				private function initGlass():void {			_bit1	= new BitmapData(data.target.width, data.target.height, false, data.background);			_bit2	= new BitmapData(_glass.width, _glass.height, false, data.background);			_bit3	= new BitmapData(data.width*2, data.height*2, false, data.background);						_filter	= new DisplacementMapFilter(_bit2, new Point(0, 0), 0, 0, 2, 2, 'color', data.background, 0);						_glass.visible	= false;			_container.mask	= _mask;						_bit1.draw(data.target);			_bit2.draw(_glass);						var bitmap:Bitmap	= new Bitmap(_bit3);			bitmap.width		= bitmap.width * 2;			bitmap.height		= bitmap.height * 2;			_container.addChild(bitmap);			_container.x		= data.target.x;			_container.y		= data.target.y;						_isLoaded	= true;		}				private function startMagnify(e:ElementEvent):void {			if(!_isLoaded) return;						var moveEye:Boolean;						var eyeW:int	= _mask.width * .5;			var eyeH:int	= _mask.height * .5;						var maxW:Number	= mouseX + eyeW;			var maxH:Number	= mouseY + eyeH;			var maskX:int	= mouseX - eyeW;			var maskY:int	= mouseY - eyeH;						if(0 <= maskX && data.target.width > maxW) {				_container.x	= maskX;				_mask.x			= maskX;				moveEye			= true;			}			if(0 < maskY && data.target.height > maxH) {				_container.y	= maskY;				_mask.y			= maskY;				moveEye			= true;			}						if(moveEye) {				//_bit3.copyPixels(_bit1, new Rectangle(mouseX * 2 - eyeW, mouseY * 2 - eyeH * 1.5, 200, 200), new Point(0, 0));				_bit3.copyPixels(_bit1, new Rectangle(mouseX - (eyeW * .5), mouseY - (eyeH * .5), data.width, data.height), new Point(0, 0));				_bit3.applyFilter(_bit3, _bit3.rect, new Point(0,0), _filter);			}		}				public override function show(duration:Number=0, delay:Number=0, callback:Function=null, params:Array=null):VisualElement {			super.show(duration, delay, callback, params);						Mouse.hide();			bind(ElementEvent.ENTER, startMagnify);						return this;		}				public override function hide(duration:Number=0, delay:Number=0, callback:Function=null, params:Array=null):VisualElement {			super.hide(duration, delay, callback, params);						Mouse.show();			unbind(ElementEvent.ENTER, startMagnify);						return this;		}	}}