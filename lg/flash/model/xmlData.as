/*** xmlData Class by Giraldo Rosales.* Visit www.liquidgear.net for documentation and updates.*** Copyright (c) 2009 Nitrogen Design, Inc. All rights reserved.* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/ package lg.flash.model {	//Flash Classes	import flash.net.URLRequest;	import flash.net.URLRequestHeader;	import flash.net.URLRequestMethod;	import flash.net.URLVariables;	import flash.system.System;		//LG Classes	import lg.flash.model.LGData;	import lg.flash.events.ElementEvent;	import lg.flash.events.ModelEvent;	import lg.flash.net.FileLoader;		public class xmlData extends LGData {		public var isLoading:Boolean		= false;		private var _queue:Vector.<String>	= new Vector.<String>();		private var _xml:Object				= {};		private var _object:Object			= {};				/** Load data from an XML file. **/		public function xmlData() {		}				/** Get data. 		*	@param name Returns all data associated with an id.		**/		public override function getData(name:String):Object {			return _data[name];		}				/** Get data. 		*	@param name Returns all data associated with an id.		**/		public function getXML(name:String):XML {			return _xml[name];		}				/** Get data. 		*	@param name Returns all data associated with an id.		**/		public function getObject(name:String):Object {			var obj:Object;						if(_object[name] == undefined) {				obj	= toObject(_xml[name]);			} else {				obj	= _object[name];			}						return obj;		}				/** Load data. 		*	@param obj Object containing all the properties to load data from an XML.		*	<ul>		*		<li><b>id</b> - <i>(required)</i>Unique id to reference data.</li>		*		<li><b>url</b> - <i>(required)</i>Relative path to xml data.</li>		*		<li><b>basePath</b> - <i>(optional)</i> BasePath for url.</li>		*	</ul>		**/		public override function load(obj:Object):void {			if(obj is String) {				return;			}						if(!isLoading) {				isLoading = true;								var req:URLRequest;				obj.basePath	= ('basePath' in obj) ? obj.basePath : '';								req				= new URLRequest(obj.basePath+obj.url);								if(obj.bustCache) {					var params:URLVariables	= new URLVariables()					params['cache']	= randRange(1000,3000);					req.data		= params;				}								req.method			= URLRequestMethod.GET;				req.contentType 	= "text/xml"; 								var ldr:FileLoader	= new FileLoader();				ldr.id				= obj.id;				ldr.ioerror(onLoadError);				ldr.loaded(onLoadComplete);				ldr.load(req);			} else {				_queue.push(obj);			}		}				/** Clear data.		*	@param id (optional) If an id is used as a parameter, it will remove all related data, otherwise all data is cleared.		**/		public function clear(id:String=''):void {			if(id != '') {				delete _data[id];			} else {				_data = null;			}		}				/** @private **/		private function onLoadComplete(e:ElementEvent):void {			var ldr:FileLoader	= e.target as FileLoader;						try {				var results:XML		= new XML(ldr.data.results);			}			catch(error:Error) {				trace('XML is malformed.', ldr.data.url);				return;			}						var ldrId:String	= ldr.id;			_data[ldrId] 		= ldr.data.results;			_xml[ldrId] 		= results;						isLoading = false;						if(_queue.length > 0) {				load(_queue.shift());			}						//Dispatch event			trigger('data_loaded', {id:ldrId, data:results, url:ldr.data.url});		}				/** @private **/		private function onLoadError(e:ElementEvent):void {			var ldr:FileLoader	= e.target as FileLoader;			var ldrId:String	= ldr.id;						trace(e);						//Dispatch event			trigger('data_io_error', {id:ldrId}, e);						//Cleanup			ldr	= null;		}				/** @private **/		private function randRange(min:Number, max:Number):Number {		    var randomNum:Number = Math.floor(Math.random() * (max - min + 1)) + min;		    return randomNum;		}				/** @private **/		private function toObject(xml:XML):Object {			if(xml == null) {				return {};			}						var obj:Object			= {};			var tmp:Object			= {};			var items:XMLList		= xml.children();			var itemName:String		= xml.localName();			var itemLen:int			= items.length();			var item:XML, inner:XMLList, objLen:int, attrLen:int, attr:XMLList, attrObj:Object, attrName:String, attrVal:String, xmlName:String;						for(var g:int=0; g<itemLen; g++) {				item	= items[g] as XML;				inner	= item.children();								if(item.nodeKind() == 'text') {					xmlName		= itemName;					obj.value	= item.toString();					tmp			= obj;				} else {					xmlName	= item.localName();										if (item != null && inner.length() == 0) {						var str:String	= item.toString();												if (obj[xmlName] == undefined) {							obj[xmlName]		= {};							obj[xmlName].value	= str;							tmp					= obj[xmlName];						} else {							if (obj[xmlName][0] == undefined) {								tmp				= obj[xmlName];								obj[xmlName]	= [];								obj[xmlName][0]	= tmp;							}														objLen		= obj[xmlName].length;							obj[xmlName][objLen]		= {};							obj[xmlName][objLen].value	= str;							tmp							= obj[xmlName][objLen];						}					} else {						if (obj[xmlName] == null) {							obj[xmlName]	= toObject(item);							tmp				= obj[xmlName];						} else {							if (obj[xmlName][0] == null) {								tmp				= obj[xmlName];								obj[xmlName]	= [];								obj[xmlName][0]	= tmp;							}														objLen					= obj[xmlName].length;							obj[xmlName][objLen]	= toObject(item);							tmp						= obj[xmlName][objLen];						}					}				}								if(tmp is Object) {					tmp.type		= xmlName;					tmp.attributes	= {};					attr			= item.attributes();					attrLen			= attr.length();										if (attrLen == 0) {						tmp.attributes = null;					} else {						for(var h:int=0; h<attrLen; h++) {							attrObj		= attr[h].name();							attrName	= attrObj.localName;							attrVal		= attr[h].toString();							tmp.attributes[attrName]	= attrVal;						}					}				}			}						return obj;		}	}}