/*** VisualElement Class by Giraldo Rosales.* Visit www.liquidgear.net for documentation and updates.*** Copyright (c) 2010 Nitrogen Labs, Inc. All rights reserved.* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package lg.flex.elements {	//Flash	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.display.Stage;	import flash.events.Event;	import flash.filters.BitmapFilter;	import flash.filters.BlurFilter;	import flash.filters.DropShadowFilter;	import flash.filters.GlowFilter;	import flash.geom.Matrix;	import flash.geom.Rectangle;		import lg.flash.effects.Reflect;	import lg.flash.events.ElementEvent;	import lg.flash.motion.Tween;	import lg.flash.motion.TweenMax;	import lg.flash.motion.easing.Quint;		import spark.components.Group;
		/**	* Dispatched when an animation begins.	* @eventType mx.events.ElementEvent.TWEENSTART	*/	[Event(name="element_tween_start", type="lg.flash.events.ElementEvent")]		/**	* Dispatched while an animation is in progress.	* @eventType mx.events.ElementEvent.TWEENUPDATE	*/	[Event(name="element_tween_update", type="lg.flash.events.ElementEvent")]		/**	* Dispatched when an animation completes.	* @eventType mx.events.ElementEvent.TWEENEND	*/	[Event(name="element_tween_end", type="lg.flash.events.ElementEvent")]			public class VisualElement extends Element {		/** Maintain aspect ratio when resizing. **/		public var aspectRatio:Boolean	= true;				/** @private **/		private var _hitArea:Sprite		= new Sprite();		/** @private **/		private var _tween:Tween;		/** @private **/		private var _isResize:Boolean	= false;				/** @private **/		protected var _layout:Object	= {};				/** Constructs a new VisualElement object **/		public function VisualElement(obj:Object=null) {			super();						//Be sure to update element when added to stage.			addEventListener('addedToStage', onInitAdd, false, 0, true);						//Set defaults			data.enabled			= false;			data.x					= 0;			data.y					= 0;			data.width				= NaN;			data.height				= NaN;						//Layout			_layout.x				= 0;			_layout.y				= 0;			_layout.top				= NaN;			_layout.bottom			= NaN;			_layout.left			= NaN;			_layout.right			= NaN;			_layout.width			= NaN;			_layout.height			= NaN;			_layout.scaleX			= 1;			_layout.scaleY			= 1;			_layout.position		= 'default';						data.position			= 'default';			data.bottom				= NaN;			data.right				= NaN;			data.minWidth			= NaN;			data.minHeight			= NaN;			data.maxWidth			= NaN;			data.maxHeight			= NaN;			data.minX				= NaN;			data.minY				= NaN;			data.maxX				= NaN;			data.maxY				= NaN;			data.percentTop			= NaN;			data.percentBottom		= NaN;			data.percentLeft		= NaN;			data.percentRight		= NaN;			data.horizontalCenter	= false;			data.verticalCenter		= false;			data.paddingTop			= 0;			data.paddingBottom		= 0;			data.paddingLeft		= 0;			data.paddingRight		= 0;						//data.percentWidth		= NaN;			//data.percentHeight	= NaN;						data.minBottom			= NaN;			data.minRight			= NaN;			data.maxBottom			= NaN;			data.maxRight			= NaN;			data.percentHCenter		= NaN;			data.percentVCenter		= NaN;			data.minHCenter			= NaN;			data.minVCenter			= NaN;			data.aspectRatio		= false;			data.aspectRatioPolicy	= 'smallest';						data.shadow				= null;			data.glow				= null;			data.blur				= null;			data.stroke				= null;			data.hoverGlow			= null;						//Set listeners			bind('element_add', onAddToStage);						//Set defined attributes			if(obj) {				setAttributes(obj);				isSetup	= true;			}		}						/** @private **/		protected override function setAttributes(obj:Object, ignore:Array=null):void {			if(!obj) {				return;			}						if(obj.stage) {				stage		= obj.stage;			}						if(obj.parent) {			//	parent		= obj.parent;			}						super.setAttributes(obj, ignore);		}				/** @private **/		private function onInitAdd(e:Event):void {			removeEventListener('addedToStage', onInitAdd);			update();		}				/*=========================		 * EFFECTS		 *=========================*/				/** Fade in element 		*	@param duration (optional) The duration of the animation. if set to 0, the element visibility is promptly set to true and alpha to 1.		*	@param delay (optional) Amount of time to wait before starting the aniamtion.		*	@param callback (optional) Function to call on completion.		*	@param params (optional) Parameters to send with function on complete.		*/		public function show(duration:Number=0, delay:Number=0, callback:Function=null, params:Array=null):VisualElement {			toFront();						if(duration) {				TweenMax.to(this, duration, {delay:delay, autoAlpha:1, ease:Quint.easeInOut, onComplete:callback, onCompleteParams:params});			} else {				hidden	= false;			}						return this;		}				/** Fade out element 		*	@param duration (optional) The duration of the animation. if set to 0, the element visibility is promptly set to false and alpha to 0.		*	@param delay (optional) Amount of time to wait before starting the aniamtion.		*	@param callback (optional) Function to call on completion.		*	@param params (optional) Parameters to send with function on complete.		*/		public function hide(duration:Number=0, delay:Number=0, callback:Function=null, params:Array=null):VisualElement {			if(duration) {				TweenMax.to(this, duration, {delay:delay, autoAlpha:0, ease:Quint.easeInOut, onComplete:callback, onCompleteParams:params});			} else {				hidden	= true;			}						return this;		}				/** Pulls the element in the front of the existing children. **/		public function toFront():void {			if(parent) {				if(parent is Group) {					var group:Group	= parent as Group;					group.setElementIndex(this, parent.numChildren-1);				} else {					parent.setChildIndex(this, parent.numChildren-1);				}			}		}		/** Pushes the element to the back, behind all the elements within the parent **/		public function toBack():void {			if(parent) {				if(parent is Group) {					var group:Group	= parent as Group;					group.setElementIndex(this, parent.numChildren-1);				} else {					parent.setChildIndex(this, 1);				}			}		}				/** Toggles the alpha and visibility of an element. 		*	@default false */		public function get hidden():Boolean {			var isHidden:Boolean	= (alpha == 0 && !visible) ? true : false;			return isHidden;		}		public function set hidden(value:Boolean):void {			data.hidden	= value;						if(value) {				alpha	= 0;				visible	= false;			} else {				alpha	= 1;				visible	= true;			}		}				/** Animate element **/		public function animate(obj:Object):void {			obj.target	= this;			new Tween(obj);		}				/** @private **/		public function slideDown(duration:Number=0, callback:Function=null):VisualElement {			return this;		}				/** @private **/		public function slideUp(duration:Number=0, callback:Function=null):VisualElement {			return this;		}				/** @private **/		public function slideToggle(duration:Number=0, callback:Function=null):VisualElement {			return this;		}				/** Fade element to specific alpha value.		*	@param opacity (optional) Opacity of element. (default: 1)		*	@param duration (optional) The duration of the animation. if set to 0, the element visibility is promptly set to true and alpha to 1. (default: 0)		*	@param callback (optional) Function to call on completion.		*	@param params (optional) Parameters to send with function on complete.		*/		public function fadeTo(opacity:Number=1, duration:Number=0, callback:Function=null, params:Array=null):VisualElement {			animate({duration:duration, alpha:opacity, ease:Quint.easeOut, onComplete:callback, onCompleteParams:params});			return this;		}				/** Flip the element horizontally **/		public function flipX():void {			scaleX = -1;		}				/** Flip the element vertically **/		public function flipY():void {			scaleY = -1;		}				/** 		*	Creates a custom hitArea for the element.		*	@param width (optional) Width of the hitArea. (default: 0)		*	@param height (optional) Height of the hitArea. (default: 0)		**/		public function hitBox(width:Number=0, height:Number=0):void {			if(width == 0) {				width	= data.width;			}						if(height == 0) {				height	= data.height;			}						_hitArea.graphics.clear();			_hitArea.graphics.beginFill(0x000000, 0);			_hitArea.graphics.drawRect(0, 0, width, height);			_hitArea.graphics.endFill();						hitArea	= _hitArea;		}				/** 		*	Creates a custom hitArea  in the shape of a circle for the element.		*	@param width (optional) Width of the hitArea. (default: 0)		*	@param height (optional) Height of the hitArea. (default: 0)		**/		public function hitSpot(width:Number=0, height:Number=0):void {			if(width == 0) {				width	= data.width *.8;			}			if(height == 0) {				height	= data.height *.8;			}						_hitArea.graphics.clear();			_hitArea.graphics.beginFill(0x000000, 0);			_hitArea.graphics.drawEllipse((data.width-width)*.5, (data.height-height)*.5, width, height);			_hitArea.graphics.endFill();						hitArea	= _hitArea;		}				/**		*	Add a drop shadow to the element.		*	@param prop Properties of the dropShadowFilter.		*	<ul>		*		<li><strong>alpha</strong>:<em>Number</em> - Alpha transparency value for the color. (default: 1)</li>		*		<li><strong>distance</strong>:<em>Number</em> - Offset distance for the shadow, in pixels. (default: 0)</li>		*		<li><strong>angle</strong>:<em>Number</em> - Angle of the shadow. (default: 45)</li>		*		<li><strong>blurX</strong>:<em>Number</em> - Amount of horizontal blur. (default: 15)</li>		*		<li><strong>blurY</strong>:<em>Number</em> - Amount of vertical blur. (default: 15)</li>		*		<li><strong>color</strong>:<em>uint</em> - Color of the shadow. (default: 0x000000)</li>		*		<li><strong>strength</strong>:<em>Number</em> - The strength of the imprint or spread. (default: 1)</li>		*		<li><strong>inner</strong>:<em>Boolean</em> - Specifies whether the shadow is an inner shadow. (default: false)</li>		*		<li><strong>knockout</strong>:<em>Boolean</em> - Specifies whether the object has a knockout effect. (default: false)</li>		*		<li><strong>quality</strong>:<em>Number</em> - The number of times to apply the filter. 1 - Low, 2 - Medium, 3 - High. (default: 3)</li>		*		<li><strong>knockout</strong>:<em>Boolean</em> - Make element invisible but keep filter. (default: false)</li>		*	</ul>		**/		public function shadow(prop:Object=null):Element {			var obj:Object	= {};						//Set defaults			obj.distance	= 0;			obj.angle		= 45;			obj.alpha		= 1;			obj.blurX		= 15;			obj.blurY		= 15;			obj.color		= 0x000000;			obj.strength	= 1;			obj.quality		= 3;			obj.inner		= false;			obj.knockout	= false;						if(!prop) {				prop	= {};			}						//Set custom properties			for(var s:String in prop) {				obj[s]	= prop[s];			}						//If shadow already exists, remove it			if(data.shadow) {				removeFilter(data.shadow, false);				data.shadow	= null;			}						//Add shadow is blur is more than 0			if(obj.blurX != 0 || obj.blurY != 0) {				data.shadow	= new DropShadowFilter(obj.distance, obj.angle, obj.color, obj.alpha, obj.blurX, obj.blurY, obj.strength, obj.quality, obj.inner, obj.knockout, obj.hideObject);				addFilter(data.shadow);			}						return this;		}				public function removeFilter(filter:BitmapFilter, update:Boolean=true):Array {			var filterList:Array	= filters;			var filterIdx:int		= filterList.indexOf(filter);						if(filterIdx >= 0) {				filterList.splice(filterIdx, 1);			}						if(update) {				filters	= filterList;			}						return filterList;		}				public function addFilter(filter:BitmapFilter, update:Boolean=true):Array {			if(!filter) {				return filters;			}						var filterList:Array	= filters;			filterList.push(filter);						if(update) {				filters	= filterList;			}						return filterList;		}				/**		*	Add a glow filter to the element.		*	@param prop Properties of the glowFilter.		*	<ul>		*		<li><strong>alpha</strong>:<em>Number</em> - Alpha transparency value for the color. (default: 1)</li>		*		<li><strong>blurX</strong>:<em>Number</em> - Amount of horizontal blur. (default: 15)</li>		*		<li><strong>blurY</strong>:<em>Number</em> - Amount of vertical blur. (default: 15)</li>		*		<li><strong>color</strong>:<em>uint</em> - Color of the glow. (default: 0xffffff)</li>		*		<li><strong>strength</strong>:<em>Number</em> - The strength of the imprint or spread. (default: 1)</li>		*		<li><strong>inner</strong>:<em>Boolean</em> - Specifies whether the glow is an inner glow. (default: false)</li>		*		<li><strong>knockout</strong>:<em>Boolean</em> - Specifies whether the object has a knockout effect. (default: false)</li>		*		<li><strong>quality</strong>:<em>Number</em> - The number of times to apply the filter. 1 - Low, 2 - Medium, 3 - High. (default: 3)</li>		*		<li><strong>knockout</strong>:<em>Boolean</em> - Make element invisible but keep filter. (default: false)</li>		*	</ul>		**/		public function glow(prop:Object=null):VisualElement {			var obj:Object	= {};			var time:Number	= .25;						//Set defaults			obj.alpha		= 1;			obj.blurX		= 15;			obj.blurY		= 15;			obj.color		= 0xffffff;			obj.strength	= 1;			obj.quality		= 3;			obj.knockout	= false;						if(!prop) {				prop	= {};			}						//Set custom properties			for(var s:String in prop) {				obj[s]	= prop[s];			}						//If glow already exists, remove it			if(data.glow) {				removeFilter(data.glow, false);				data.glow	= null;			}						//Add shadow is blur is more than 0			if(obj.blurX != 0 || obj.blurY != 0) {				data.glow	= new GlowFilter(obj.color, obj.alpha, obj.blurX, obj.blurY, obj.strength, obj.quality, obj.inner, obj.knockout);				addFilter(data.glow);			}						return this;		}				/**		*	Creates a glow around the element when the mouse is over and removes it when mouse moves out.		*	@param size (optional) Size of the glow. (default: 10).		*	@param color (optional) Color of the glow. (default: 0xffffff).		**/		public function hoverGlow(size:Number=10, color:uint=0xffffff):void {			if(size > 0) {				data.hoverGlowSize	= size;				data.hoverGlow		= new GlowFilter(color, 0, size, size);				addFilter(data.hoverGlow);				hover(onGlowOn, onGlowOff);			} else {				unbind(ElementEvent.MOUSEOVER, onGlowOn);				unbind(ElementEvent.MOUSEOUT, onGlowOff);				removeFilter(data.hoverGlow);			}		}				/** @private **/		private function onGlowOn(e:ElementEvent):void {			var glow:GlowFilter	= data.hoverGlow as GlowFilter;			new Tween({target:glow, duration:.25, alpha:1, blurX:data.hoverGlowSize, blurY:data.hoverGlowSize});		}				/** @private **/		private function onGlowOff(e:ElementEvent):void {			var glow:GlowFilter	= data.hoverGlow as GlowFilter;			new Tween({target:glow, duration:.25, alpha:0, blurX:0, blurY:0});		}				/**		*	Creates a stroke around an element.		*	@param size (optional) Size of the stroke. (default: 1).		*	@param color (optional) Color of the stroke. (default: 0x000000).		**/		public function stroke(size:Number=2, color:uint=0x000000):Element {			//If stroke already exists, remove it			if(data.stroke) {				removeFilter(data.stroke, false);				data.stroke	= null;			}						//Add stroke size is more than 0			if(size != 0) {				data.stroke	= new GlowFilter(color, 1, size, size, 1000, 1, false, false);				addFilter(data.stroke);			}						return this;		}				/**		*	Blur an object. 		*	@param prop Variables used to blur.		*	<ul>		*		<li><strong>blurX</strong>:<em>Number</em> - (optional) The amount of horizontal blur. (default: .15)</li>		*		<li><strong>blurY</strong>:<em>Number</em> - (optional) The amount of vertical blur. (default: .15)</li>		*		<li><strong>quality</strong>:<em>Number</em> - (optional) The quality of the blur. (default: 1)</li>		*		<li><strong>duration</strong>:<em>Number</em> - (optional) If animating, duration of time to blur from previous values. (default: 0)</li>		*	</ul>		**/		public function blur(prop:Object=null):void {			var obj:Object={};			var filterArr:Array;						obj.blurX		= .15;			obj.blurY		= .15;			obj.quality		= 1;			obj.duration	= 0;						if(prop) {				//Set custom properties				for(var s:String in prop) {					obj[s]	= prop[s];				}			}						//If blur already exists, remove it			if(data.blur) {				removeFilter(data.blur, false);				data.blur	= null;			}						//Add blur size is more than 0			if(obj.blurX != 0 || obj.blurY != 0) {				data.blur	= new BlurFilter(obj.blurX, obj.blurY, obj.quality);				filterArr	= addFilter(data.blur, false);			}						if(obj.duration > 0) {				var blur:BlurFilter	= data.blur as BlurFilter;				blur.blurX			= 0;				blur.blurY			= 0;				filters	= filterArr;								new Tween({target:blur, duration:obj.duration, blurX:obj.blurX, blurY:obj.blurY, ease:Quint.easeInOut});			} else {				filters	= filterArr;			}		}				/**		*	Create a reflection. 		*	@param prop Variables used to create reflection.		*	<ul>		*		<li><strong>alpha</strong>:<em>Number</em> - (optional) Opacity of the reflection. (default: .25)</li>		*		<li><strong>ratio</strong>:<em>Number</em> - (optional) Ratio of the glare. (default: 100)</li>		*		<li><strong>distance</strong>:<em>Number</em> - (optional) Distance from original element. (default: 0)</li>		*		<li><strong>updateTime</strong>:<em>Number</em> - (optional) Time persiod to update reflection. Use when animating element. To save on performance, set to -1 to turn off if not animating the element. (default: -1)</li>		*		<li><strong>reflectionDropoff</strong>:<em>Number</em> - (optional) Rate at which to fade. (default: 0)</li>		*	</ul>		**/		public function reflect(prop:Object=null):void {			var reflect:Reflect, obj:Object={};						obj.target				= this;			obj.alpha				= .25;			obj.ratio				= 100;			obj.distance			= 0;			obj.updateTime			= -1;			obj.reflectionDropoff	= 0;						for(var s:String in prop) {				obj[s] = prop[s];			}						reflect = new Reflect(obj);		}				/**		*	Set the size of the element		*	@param Set width.		*	@param Set height.		**/		public function setSize(width:Number, height:Number):void {			this.width	= width;			this.height	= height;		}				/**		*	Set the position of the element		*	@param Set x position.		*	@param Set y position.		**/		public function getSize():Rectangle {			var rect:Rectangle = new Rectangle(x, y, width, height);			return rect;		}				/**		*	Set the position of the element		*	@param Set x position.		*	@param Set y position.		**/		public function setPos(x:Number, y:Number, z:Number=0):void {			_layout.top		= NaN;			_layout.left	= NaN;						this.x	= x;			this.y	= y;		}				/** Get the bounds of the element **/		public function elementBounds():Rectangle {			var bounds:Rectangle	= new Rectangle(0, 0, width, height);			return bounds;		}				/** 		*	Scale element.		*	@param xScale Amount to scale along the x-axis.		*	@param yScale (optional) Amount to scale along the y-axis. If not set, yScale is set equal to xScale.		**/		public function scale(xScale:Number, yScale:Number=-1):void {			if(yScale < 0) {				scaleX	= scaleY = data.scaleX = data.scaleY = xScale;			} else {				scaleX	= data.scaleX = xScale;				scaleY	= data.scaleY = yScale;			}						_layout.scaleX	= scaleX;			_layout.scaleY	= scaleY;		}				/** Makes the element visible to the eye but invisible to the mouse. **/		public function ghost():void {			buttonMode		= false;			useHandCursor	= false;			mouseEnabled	= false;			mouseChildren	= false;		}				/** Gives the element button attributes. **/		public function button():void {			buttonMode		= true;			useHandCursor	= true;			mouseEnabled	= true;			mouseChildren	= false;		}				/** Toggles enable value. **/		public function set enabled(value:Boolean):void {			data.enabled	= value;		}		public function get enabled():Boolean {			return data.enabled;		}				/** References the Stage. Can add the stage if element has not yet been added. **/		public function set stage(container:Stage):void {			data.stage	= container;		}		public override function get stage():Stage {			if(super.stage) {				return super.stage;			} else if(data) {				return data.stage;			} else {				return null;			}		}						public override function get width():Number {			if(data && data.width != undefined && data.width > 0) {				return data.width;			} else {				var rect:Rectangle	= super.getBounds(this);				return rect.width;			}		}		public override function set width(value:Number):void {			data.width	= value;			super.width	= value;			//if(stretch && value != _layout.width) {			//	_layout.width	= value;			//	reposition();			//}		}		/*		public function get maxWidth():Number {			return data.maxWidth;		}		public function set maxWidth(value:Number):void {			if(value != data.maxWidth) {				data.maxWidth	= value;				reposition();			}		}				public function get minWidth():Number {			return data.minWidth;		}		public function set minWidth(value:Number):void {			if(value != data.minWidth) {				data.minWidth	= value;				reposition();			}		}		*/		public override function get height():Number {			if(data && data.height != undefined && data.height > 0) {				return data.height;			} else {				var rect:Rectangle	= super.getBounds(this);				return rect.height;			}		}				public override function set height(value:Number):void {			data.height		= value;			super.height	= value;			//if(stretch && value != _layout.height) {			//	_layout.height	= value;			//	reposition();			//}		}		/*		public function get minHeight():Number {			return data.minHeight;		}		public function set minHeight(value:Number):void {			if(value != data.minHeight) {				data.minHeight	= value;				reposition();			}		}				public function get maxHeight():Number {			return data.maxHeight;		}		public function set maxHeight(value:Number):void {			if(value != data.maxHeight) {				data.maxHeight	= value;				reposition();			}		}				public override function get x():Number {			return data.x;		}				public override function set x(value:Number):void {			data.x	= value;						if(value != _layout.left) {				_layout.left	= value;				reposition();			}		}				public function get minX():Number {			return data.minX;		}		public function set minX(value:Number):void {			if(value != data.minX) {				data.minX	= value;				reposition();			}		}				public function get maxX():Number {			return data.maxX;		}		public function set maxX(value:Number):void {			if(value != data.maxX) {				data.maxX	= value;				reposition();			}		}				public override function get y():Number {			return data.y;		}				public override function set y(value:Number):void {			data.y	= value;						if(value != _layout.top) {				_layout.top	= value;				reposition();			}		}				public function get minY():Number {			return data.minY;		}		public function set minY(value:Number):void {			if(value != data.minY) {				data.minY	= value;				reposition();			}		}				public function get maxY():Number {			return data.maxY;		}		public function set maxY(value:Number):void {			if(value != data.maxY) {				data.maxY	= value;				reposition();			}		}				public function get paddingTop():Number {			return data.paddingTop;		}		public function set paddingTop(value:Number):void {			data.paddingTop	= value;		}				public function get paddingBottom():Number {			return data.paddingBottom;		}		public function set paddingBottom(value:Number):void {			data.paddingBottom	= value;		}				public function get paddingLeft():Number {			return data.paddingLeft;		}		public function set paddingLeft(value:Number):void {			data.paddingLeft	= value;		}				public function get paddingRight():Number {			return data.paddingRight;		}		public function set paddingRight(value:Number):void {			data.paddingRight	= value;		}				public function get position():String {			return data.position;		}		public function set position(value:String):void {			var pos:String		= value.toLowerCase();			data.position		= pos;						if(_layout.position == pos) {				return;			}						switch(pos) {				case 'horizontalCenter':					data.horizontalCenter	= true;					break;				case 'verticalCenter':					data.verticalCenter		= true;					break;				case 'center':					data.horizontalCenter	= true;					data.verticalCenter		= true;					break;				case 'stretch':					data.x					= 0;					data.y					= 0;					data.width				= parentWidth;					data.height				= parentHeight;					stretch					= true;					break;				case 'stretchMin':					data.horizontalCenter	= true;					data.verticalCenter		= true;					data.minWidth			= data.width;					data.minHeight			= data.height;					break;				case 'stretchMax':					data.horizontalCenter	= true;					data.verticalCenter		= true;					data.maxWidth			= data.width;					data.maxHeight			= data.height;					break;				default:					data.horizontalCenter	= false;					data.verticalCenter		= false;					data.position	= 'default';					break;			}						_layout.position	= data.position;						reposition();		}				public override function set visible(value:Boolean):void {			if(value) {				startResizing();			} else {				stopResizing();			}						super.visible	= value;		}				*/		/** @private **/		private function get parentWidth():Number {			var w:int;						if(parent) {				w	= parent.width;			} else if(stage) {				w	= stage.stageWidth;			} else {				//trace(id + ': Stage or parent property is required.');				w	= 0;			}						return w;		}				/** @private **/		private function get parentHeight():Number {			var h:int;						if(parent) {				h	= parent.height;			} else if(stage) {				h	= stage.stageHeight;			} else {				//trace(id + ': Stage or parent property is required.');				h	= 0;			}						return h;		}				private function onAddToStage(e:ElementEvent):void {			isSetup	= true;			//startResizing();		}		/*		private function startResizing():void {			if(!_isResize && stage) {				_isResize	= true;				stage.addEventListener('resize', onResizeStage);				reposition();			}		}				private function stopResizing():void {			if(_isResize && stage) {				_isResize	= false;				stage.removeEventListener('resize', onResizeStage);			}		}				private function onResizeStage(e:Event):void {			update();		}				private function reposition():void {			if(!isSetup) {				return;			}						var tmpX:int;			var tmpY:int;			var tmpW:int;			var tmpH:int;			var autoPos:Boolean	= false;						//Get stage size			var stageW:int	= parentWidth;			var stageH:int	= parentHeight;						//Set anchor points			var stretchW:Boolean	= false;			var stretchH:Boolean	= false;						if(!isNaN(_layout.top) && !isNaN(_layout.bottom)) {				stretchH	= true;			}			if(!isNaN(_layout.left) && !isNaN(_layout.right)) {				stretchW	= true;			}						//Width			if(stretchW) {				tmpW	= stageW;								if(!isNaN(data.percentLeft) || !isNaN(data.percentRight)) {					if(!isNaN(data.percentLeft)) {						tmpW	-= stageW * data.percentLeft;					} else {						tmpW	-= _layout.left;					}										if(!isNaN(data.percentRight)) {						tmpW	-= stageW * data.percentRight;					} else {						tmpW	-= _layout.right;					}				} else {					tmpW	-= _layout.left - _layout.right;				}								_layout.width	= tmpW;			}						//Height			if(stretchH) {				_layout.height	= (stageH - _layout.bottom) - _layout.top;			}						if(!isNaN(_layout.height)) {				if(!isNaN(data.percentBottom)) {					if(!_layout.height) {						_layout.height	= stageH - (stageH * data.percentBottom);												if(!isNaN(_layout.top)) {							_layout.height	-= _layout.top;						}					}				}			}						//Get current width and height			tmpW	= (_layout.width) ? _layout.width : super.width;			tmpH	= (_layout.height) ? _layout.height : super.height;						//X position			if(data.horizontalCenter) {				_layout.x	= (stageW * .5) - (tmpW * .5);			}			else if(!stretchW && !isNaN(_layout.right)) {				_layout.x	= stageW - (super.width + _layout.right);			}			else if(!isNaN(_layout.left)) {				if(!isNaN(data.percentLeft)) {					_layout.x	= stageW * data.percentLeft;				} else {					_layout.x	= _layout.left;				}			}						//Y position			if(data.verticalCenter) {				_layout.y	= (stageH * .5) - (tmpH * .5);			}			else if(!stretchH && _layout.bottom && isNaN(data.percentBottom)) {				_layout.y		= stageH - (tmpH - _layout.bottom);			}			else if(!isNaN(_layout.top)) {				if(!isNaN(data.percentTop)) {					_layout.top	= stageH * data.percentTop;				}								_layout.y	= _layout.top;			} else {				if(!isNaN(_layout.height)) {					_layout.y	= stageH - (stageH * data.percentBottom) - _layout.height;				}			}						//Stay within the constraints			//Set X			if(data.horizontalCenter){				if(!isNaN(data.minX) && data.minX > _layout.x) {					_layout.x	= data.minX;				}				if(!isNaN(data.maxX) && data.maxX < _layout.x) {					_layout.x	= data.maxX;				}			}						super.x	= _layout.x;						//Set Y			if(data.verticalCenter){				if(!isNaN(data.minY) && data.minY > _layout.y) {					_layout.y	= data.minY;				}				if(!isNaN(data.maxY) && data.maxY < _layout.y) {					_layout.y	= data.maxY;				}			}						super.y	= _layout.y;						//Set Width			if(!isNaN(_layout.width)) {				if(!isNaN(data.minWidth) && data.minWidth > _layout.width) {					_layout.width	= data.minWidth;				}								if(!isNaN(data.maxWidth) && (data.maxWidth < _layout.width)) {					_layout.width	= data.maxWidth;				}								if(super.width > 0) {					super.width		= _layout.width;				}			}						//Set Height			if(!isNaN(_layout.height)) {				if(!isNaN(data.minHeight) && data.minHeight > _layout.height) {					_layout.height	= data.minHeight;				}								if(!isNaN(data.maxHeight) && (data.maxHeight < _layout.height)) {					_layout.height	= data.maxHeight;				}								if(super.height > 0) {					super.height	= _layout.height;				}			}						//Aspect ratio			if(aspectRatio) {				scaleX < scaleY ? scaleY = scaleX : scaleX = scaleY;			} else {				scaleX	= _layout.scaleX;				scaleY	= _layout.scaleY;			}		}		*/		public function getBitmapData():BitmapData {			var bData:BitmapData = new BitmapData(width, height, true, 0x000000);			bData.draw(this);						return bData;		}		/*		private function invalidate(value1:*, value2:*):void {			if (value1 != value2) {				reposition();			}		}		*/		/** Update the elements properties. **/		public override function update(obj:Object=null):void {			//reposition();		}				/** Kill the object and clean from memory. **/		public override function kill():void {			super.kill();		}	}}